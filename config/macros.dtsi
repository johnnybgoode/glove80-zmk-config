ZMK_MACRO(dot_dot, 
  wait-ms = <0>;
  tap-ms = <0>;
  bindings = <&macro_tap &kp DOT &kp DOT>; 
)

ZMK_MACRO_ONE_PARAM(mod_tab,
  wait-ms = <0>;
  tap-ms = <0>;
  bindings
  = <&macro_param_1to1>
  , <&macro_press &kp MACRO_PLACEHOLDER>
  , <&macro_tap &kp TAB>
  , <&macro_pause_for_release>
  , <&macro_param_1to1> 
  , <&macro_release &kp MACRO_PLACEHOLDER>
  ;
)

ZMK_MACRO_TWO_PARAM(mod_tab_chord,
  wait-ms = <0>; 
  tap-ms = <0>; 
  bindings 
  = <&macro_param_2to1>
  , <&macro_press &mo MACRO_PLACEHOLDER> 
  , <&macro_param_1to1> 
  , <&macro_press &mod_tab MACRO_PLACEHOLDER> 
  , <&macro_pause_for_release> 
  , <&macro_param_1to1> 
  , <&macro_release &mod_tab MACRO_PLACEHOLDER> 
  , <&macro_param_2to1> 
  , <&macro_release &mo MACRO_PLACEHOLDER> 
  ;
)

//
// SELECT_WORD_DELAY defines how long the macro waits (milliseconds)
// after moving the cursor before it selects a word.  A larger delay
// may allow the macro to move to the next word upon each invocation.
//
#define SELECT_WORD_DELAY 1
#define select_all kp _C(A)

ZMK_MACRO(select_none,
  wait-ms = <SELECT_WORD_DELAY>;
  tap-ms = <SELECT_WORD_DELAY>;
  bindings = <&kp DOWN &kp UP &kp RIGHT &kp LEFT>;
)

//
// select a word (jumps to next word upon each successive invocation)
//
ZMK_MOD_MORPH(select_word,
  bindings = <&select_word_right>, <&select_word_left>; 
  mods = <(MOD_LSFT|MOD_RSFT)>;
)
ZMK_MACRO(select_word_right,
  wait-ms = <SELECT_WORD_DELAY>; 
  tap-ms = <SELECT_WORD_DELAY>; 
  bindings = <&kp _WORD(RIGHT) &kp _WORD(LEFT) &kp _WORD(LS(RIGHT))>;
)
ZMK_MACRO(select_word_left,
  wait-ms = <SELECT_WORD_DELAY>; 
  tap-ms = <SELECT_WORD_DELAY>; 
  bindings = <&kp _WORD(LEFT) &kp _WORD(RIGHT) &kp _WORD(LS(LEFT))>;
)

//
// extend current selection by one word
//
ZMK_MOD_MORPH(extend_word,
  bindings = <&extend_word_right>, <&extend_word_left>; 
  mods = <(MOD_LSFT|MOD_RSFT)>;
)
ZMK_MACRO(extend_word_right,
  wait-ms = <SELECT_WORD_DELAY>;
  tap-ms = <SELECT_WORD_DELAY>;
  bindings = <&kp _WORD(LS(RIGHT))>;
)
ZMK_MACRO(extend_word_left,
  wait-ms = <SELECT_WORD_DELAY>;
  tap-ms = <SELECT_WORD_DELAY>;
  bindings = <&kp _WORD(LS(LEFT))>;
)

//
// select current line
//
ZMK_MOD_MORPH(select_line,
  bindings = <&select_line_right>, <&select_line_left>;
  mods = <(MOD_LSFT|MOD_RSFT)>;
)
ZMK_MACRO(select_line_right,
  wait-ms = <SELECT_WORD_DELAY>;
  tap-ms = <SELECT_WORD_DELAY>;
  bindings = <&kp _HOME &kp LS(_END)>;
)
ZMK_MACRO(select_line_left,
  wait-ms = <SELECT_WORD_DELAY>;
  tap-ms = <SELECT_WORD_DELAY>;
  bindings = <&kp _END &kp LS(_HOME)>;
)

//
// extend current selection by one line
//
ZMK_MOD_MORPH(extend_line,
  bindings = <&extend_line_right>, <&extend_line_left>; 
  mods = <(MOD_LSFT|MOD_RSFT)>;
)
ZMK_MACRO(extend_line_right,
  wait-ms = <SELECT_WORD_DELAY>;
  tap-ms = <SELECT_WORD_DELAY>;
  bindings = <&kp LS(DOWN) &kp LS(_END)>;
)
ZMK_MACRO(extend_line_left,
  wait-ms = <SELECT_WORD_DELAY>;
  tap-ms = <SELECT_WORD_DELAY>;
  bindings = <&kp LS(UP) &kp LS(_HOME)>;
)

// Vim macros
ZMK_MACRO(cln_w_q,
  wait-ms = <0>;
  tap-ms  = <0>;
  bindings = <&kp ESC &kp LS(SEMI) &kp W &kp Q>;
)

ZMK_MACRO(q_bang,
  wait-ms = <0>;
  tap-ms  = <0>;
  bindings = <&kp ESC &kp LS(SEMI) &kp Q &kp LS(N1)>;
)

ZMK_MACRO(tilda_slsh,
  wait-ms = <0>;
  tap-ms  = <0>;
  bindings = <&kp LS(GRAVE) &kp FSLH>;
)
